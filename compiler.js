#!/usr/bin/env node

const cp = require("child_process");
const fs = require("fs");
const path = require("path");
const rl = require("readline").createInterface({
	"input": process.stdin,
	"output": process.stdout
});

if(process.argv.length < 3)
{
	throw "Usage:\r\n\tcompiler <file.sssc> [-c]";
};

function getType(word)
{
	return word.slice(0, 3);
};

function getString(word)
{
	if(getType(word) == "str")
		return word.slice(6, -1);
	else
		throw "Error: Trying to get the string of a word that isn't a string | ABORTING... ";
};

function getInt(word)
{
	if(getType(word) == "int")
		return Number(word.slice(5, word.length));
	else
		throw "Error: Trying to get the integer of a word that isn't an integer | ABORTING...";
};

function gen(pcode)
{
	let final = "";
	let start = "/*Generated by NodeJS version of SuperSimple Compiler*/\r\n\r\nint main(int argc, char** argv)\r\n{\r\n";
	let end = "}\r\n";
	let output = "";
	let includes = [];
	let layer = 1;
	let nword = pcode.length; //Oh
	for(var i = 0;i < nword;i++)
		switch(pcode[i])
		{
			case "PRINT":
				i += 1;
				if(!includes.includes("stdio.h"))
					includes.push("stdio.h");
				if(getType(pcode[i]) == "str")
				{
					for(var j = 0;j < layer;j++)
						output += "\t";
					output += "printf(\"%s\", \"" + getString(pcode[i]) + "\\r\\n\");\r\n";
				};
			break;
			case "RETURN":
				i += 1;
				if(getType(pcode[i]) == "int")
				{
					for(var j = 0;j < layer;j++)
						output += "\t";
					output += "return " + getInt(pcode[i]).toString().concat(";\r\n");
				};
			break;
		};
	includes.forEach(function(module){
		final += "#include <"+module+">\r\n";
	});
	final += "\r\n";
	final += start;
	final += output;
	final += end;
	return final;
};

function parseAndLex(code)
{
	let token = "";
	let readingString = 0;
	let wroteString = "";
	let tokens = [];
	let chars = code.split("");
	chars.forEach(function(char){
		token += char;
		switch(token.toLowerCase())
		{
			case " ":
			case "\n":
			case "\r":
			case "\t":
				token = "";
			break;
			case "print":
				tokens.push("PRINT");
				token = "";
			break;
			case "return":
				tokens.push("RETURN");
				token = "";
			break;
			case "\"":
				if(readingString == 0)
					readingString += 1;
				else
				{
					readingString -= 1;
					if(readingString == 0)
					{
						tokens.push("str::"+wroteString+"\"");
						wroteString = "";
					};
					token = "";
				};
			break;
			default:
				if(token.match(/\d/) && !isNaN(Number(token)))
					tokens.push("int::"+token.match(/\d+/)[0]);
		};
		if(readingString !== 0)
		{
		wroteString += char;
			token = "";
		};
	});
	return tokens;
};

function main(){
	console.log("Trying to open the provided file...");
	fs.readFile(path.join(process.cwd(), process.argv[2]), {"encoding": "utf-8", "flag": "r"}, function(err, file){
		if(err)
			throw "Error reading/accessing the provided file :(";
		else
		{
			let oname = process.argv[2].slice(0, -5).concat(".c");
			console.log("Lexing and Parsing...");
			let parsed = parseAndLex(file);
			console.log("Generating...");
			let out = gen(parsed);
			console.log("Trying to open the output file...");
			fs.writeFile(oname, out, {"encoding": "utf-8", "flag": "w"}, function(err){
				if(err)
					throw "Can't write to the output file :(";
				else
				{
					if(process.argv[2] !== "-c" && process.argv[2] !== "-ec" && process.argv[2] !== "-ce" && process.argv[3] !== "-c")
						rl.question("Would you like to compile the file with GCC (Install MinGW if you're on Windows) ? [Y/n]: ", function(cyn){
							if(cyn.toLowerCase() !== "n")
							{
								let gcc = cp.spawn("gcc", [oname, "-o", process.platform === "win32" ? oname.slice(0, -2).concat(".exe") : oname.slice(0, -2)]);
								gcc.stdout.on("data", function(d){console.log(d);});
								process.stdin.pipe(gcc.stdin);
								gcc.on("exit", function(){
									process.stdin.pause();
									console.log("Goodbye");
									process.exit(0);
								});
							}
							else
							{
								console.log("Goodbye");
								process.exit(0);
							};
						});
					else
					{
						if(cyn.toLowerCase() !== "n")
						{
							let gcc = cp.spawn("gcc", [oname, "-o", process.platform === "win32" ? oname.slice(0, -2).concat(".exe") : oname.slice(0, -2)]);
							gcc.stdout.on("data", function(d){console.log(d);});
							gcc.on("exit", function(){
								console.log("Goodbye");
								process.exit(0);
							});
						}
						else
						{
							console.log("Goodbye");
							process.exit(0);
						};
					};
				};
			});
			console.log("(Over)writing the output file...");
		};
	});
};

main();
